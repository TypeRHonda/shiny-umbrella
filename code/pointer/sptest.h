#include <stdio.h>

template <typename T>
class Csptr {
	class Cwrap { // Internal wrapper for data, which counts references to itself
//////////////////////////////////////////////////////////////////////////
///  @brief Конструктор
//////////////////////////////////////////////////////////////////////////
		Cwrap(T *value) : m_value(value), m_ref(0) { }

//////////////////////////////////////////////////////////////////////////
///  @brief Деструктор
//////////////////////////////////////////////////////////////////////////
		~Cwrap() { }

//////////////////////////////////////////////////////////////////////////
///  @brief Увеличить счетчик ссылок
//////////////////////////////////////////////////////////////////////////
		void AddRef() {
			m_ref++;
		}

//////////////////////////////////////////////////////////////////////////
///  @brief Уменьшить счетчик ссылок
//////////////////////////////////////////////////////////////////////////
		void Release() {
			if (--m_ref == 0) {
				Cleanup();
				delete this;
			}
		}

//////////////////////////////////////////////////////////////////////////
///  @brief Доступ к содержимому
//////////////////////////////////////////////////////////////////////////
		T *value() {
			return m_value;
		}

//////////////////////////////////////////////////////////////////////////
///  @brief Метод очистки хэндла. Должен быть определен для каждой специализации
//////////////////////////////////////////////////////////////////////////
		virtual void Cleanup(); // Cleanup function. Must be defined for every used specialization

		T *m_value;
		int m_ref;

		friend class Csptr;
	};

public:
//////////////////////////////////////////////////////////////////////////
///  @brief Пустой конструктор
//////////////////////////////////////////////////////////////////////////
	Csptr() : m_wrap(NULL) {}

//////////////////////////////////////////////////////////////////////////
///  @brief Конструктор копирования
//////////////////////////////////////////////////////////////////////////
	Csptr(const Csptr &rval) {  // Doesn't work without 'const'
		m_wrap = rval.m_wrap;
		m_wrap->AddRef();
#ifdef _DEBUG
		printf("Smart pointer created from copy\n");
#endif
	}

//////////////////////////////////////////////////////////////////////////
///  @brief Конструктор с инициализацией
//////////////////////////////////////////////////////////////////////////
	Csptr(T &val) {
		m_wrap = new Cwrap(&val);
		m_wrap->AddRef();
#ifdef _DEBUG
		printf("Smart pointer created\n");
#endif
	}

//////////////////////////////////////////////////////////////////////////
///  @brief Деструктор
//////////////////////////////////////////////////////////////////////////
	~Csptr() {
		if (m_wrap)
			m_wrap->Release();
#ifdef _DEBUG
		else
			printf("Non-initialized ");
		printf("Smart pointer destroyed\n");
#endif
		m_wrap = NULL;
	}

/////////////////////////////////////////////////////////////////////////
///  @brief Разыменовать умный указатель. Для неинициализированных указателей вернет NULL
//////////////////////////////////////////////////////////////////////////
	const T &operator * () const {
		if (m_wrap == NULL) {
			printf("Dereferencing null pointer!\n"); // Handle the error!
			return NULL;
		}
		return *m_wrap->value();
	}

//////////////////////////////////////////////////////////////////////////
///  @brief Разыменовать умный указатель. Для неинициализированных указателей вернет NULL
//////////////////////////////////////////////////////////////////////////
	T *const operator -> () const {
		if (m_wrap == NULL) {
			printf("Dereferencing null pointer!\n"); // Handle the error!
			return NULL;
		}
		return m_wrap->value();
	}

//////////////////////////////////////////////////////////////////////////
///  @brief Оператор копирования умного указателя
//////////////////////////////////////////////////////////////////////////
	Csptr &operator = (const Csptr &rval) {
		if (m_wrap)
			m_wrap->Release();
		m_wrap = rval.m_wrap;
		m_wrap->AddRef();
		return *this;
	}
//////////////////////////////////////////////////////////////////////////
///  @brief Оператор копирования умного указателя из обычного
//////////////////////////////////////////////////////////////////////////
	Csptr &operator = (T *rval) {
		if (m_wrap)
			m_wrap->Release();
		m_wrap = new Cwrap(rval);
		m_wrap->AddRef();
		return *this;
	}

//////////////////////////////////////////////////////////////////////////
///  @brief make the pointer invalid, removing reference to object
//////////////////////////////////////////////////////////////////////////
	void Unlink() {
		if (m_wrap)
			m_wrap->Release();
		m_wrap = NULL;
	}

//////////////////////////////////////////////////////////////////////////
///  @brief Returns whether the smart pointer is valid
//////////////////////////////////////////////////////////////////////////
	bool IsValid() {
		return m_wrap != NULL;
	}
protected:
	Cwrap *m_wrap;
};

// These macro definitions should wrap the cleanup definition.
// Wrapped value can be accessed as m_value
//////////////////////////////////////////////////////////////////////////
///  @brief Макрос начала объявления специализации умного указателя
//////////////////////////////////////////////////////////////////////////
#define SMARTPTR_CLEANUP_BEGIN(name, type) typedef Csptr<type> name; \
template <> void Csptr<type>::Cwrap::Cleanup() {

//////////////////////////////////////////////////////////////////////////
///  @brief Макрос окончания объявления специализации умного указателя
//////////////////////////////////////////////////////////////////////////
#define SMARTPTR_CLEANUP_END }
