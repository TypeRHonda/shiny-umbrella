#define CRT_SECURE_NO_WARNINGS
#include <DxLib.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
?
?
// 함수 전반적으로 사용하는 변수 정의 및 랜덤 정의
#define True 1
#define False 0 
#define Clear 2
#define Random(n) (rand()%n)
?
// 키입력 전역변수들
int menu_key[256];
int Dodge_key[256];
int Dodge_moving_key[256];
int start_key[256];
int character_key[256];
int testris_key[256];
int skyrimExit_key[256];
int selectOption_key[256];
int attackOption_key[256];
int skillOption_key[256];
int itemOption_key[256];
?
// 함수들에 대한 키 입력 함수
int gpUpdateKey();
int StartGpUpdateKey();
int DodgeGpUpdateKey();
int DodgeMovingGpUpdateKey();
int SkyrimCharacterMovingKey();
int TestrisMovingKey();
int SkyrimExitMovingKey(); 
int SelectOptionKey();
int AttackOptionKey();
int SkillOptionKey();
int ItemOptionKey();
?
// 화면 함수들
void StartScreen();
void FirstMenu();
void Dodge_level1();
void Skyrim();
void Tetris();
void StartSkyrim();
void sleep(unsigned int wait);
void DrawMap();
void MonsterHeroDrawMap();
void MonsterHero();
void MonsterApperance();
void DodgeDraw();
void HeroAttack();
void HeroSkill();
void HeroItem();
?
// 색 전역변수 정의
int White = GetColor(255, 255, 255);
int Black = GetColor(0, 0, 0);
int Green = GetColor(0, 255, 0);
int Red?? = GetColor(0, 0, 255);
int Blue? = GetColor(0, 0, 255);
?
// Menu 전역변수
#define MENU_NUM 5
int menu_selectNum = 0;
?
typedef struct{
????int x, y;
????char name[20];
} Menu;
typedef struct{
????int x, y;
????char name[20];
} EXIT_OPTION;
typedef struct{
????int x, y;
????char name[20];
} Status;
typedef struct{
????int x, y;
????char name[20];
} SelectOption;
typedef struct{
????int x, y;
????char name[20];
} AttackName;
typedef struct node{
????float bul_x; float bul_y;?? // bullet 좌표
????struct node *next;
????struct node *prev;
} BULLET;
?
// Dodge DLinked List & variable
BULLET *Head = NULL;
BULLET *Tail = NULL;
BULLET *Curr = NULL;
BULLET *bullet = NULL;
int bulCount;
int check;
?
// 키 관련 함수들
void sleep(unsigned int wait)
{
????clock_t goal;
????goal = (clock_t)(wait * CLOCKS_PER_SEC / 1000.0) + clock();
????while (goal > clock());
}
int SkyrimCharacterMovingKey()
{
????char tmpKey[256];
????GetHitKeyStateAll(tmpKey);
?
????for (int i = 0; i < 256; i++){
????????if (tmpKey[i] != 0){
????????????character_key[i]++;
????????}
????????else{
????????????character_key[i] = 0;
????????}
????}
????return 0;
}
int SkyrimExitMovingKey()
{
????char tmpKey[256];
????GetHitKeyStateAll(tmpKey);
?
????for (int i = 0; i < 256; i++){
????????if (tmpKey[i] != 0){
????????????skyrimExit_key[i]++;
????????}
????????else{
????????????skyrimExit_key[i] = 0;
????????}
????}
????return 0;
}
int TestrisMovingKey()
{
????char tmpKey[256];
????GetHitKeyStateAll(tmpKey);
?
????for (int i = 0; i < 256; i++){
????????if (tmpKey[i] != 0){
????????????testris_key[i]++;
????????}
????????else{
????????????testris_key[i] = 0;
????????}
????}
????return 0;
}
int gpUpdateKey()?? // 입력된 키 저장 하는 함수
{
????char tmpKey[256];
????GetHitKeyStateAll(tmpKey);
?
????for (int i = 0; i < 256; i++){
????????if (tmpKey[i] != 0){
????????????menu_key[i]++;
????????}
????????else{
????????????menu_key[i] = 0;
????????}
????}
????return 0;
}
int StartGpUpdateKey()? // 입력된 키 저장 하는 함수
{
????char tmpKey[256];
????GetHitKeyStateAll(tmpKey);
?
????for (int i = 0; i < 256; i++){
????????if (tmpKey[i] != 0){
????????????start_key[i]++;
????????}
????????else{
????????????start_key[i] = 0;
????????}
????}
????return 0;
}
int DodgeGpUpdateKey()? // 입력된 키 저장 하는 함수
{
????char tmpKey[256];
????GetHitKeyStateAll(tmpKey);
?
????for (int i = 0; i < 256; i++){
????????if (tmpKey[i] != 0){
????????????Dodge_key[i]++;
????????}
????????else{
????????????Dodge_key[i] = 0;
????????}
????}
????return 0;
}
int DodgeMovingGpUpdateKey()??? // 입력된 키 저장 하는 함수
{
????char tmpKey[256];
????GetHitKeyStateAll(tmpKey);
?
????for (int i = 0; i < 256; i++){
????????if (tmpKey[i] != 0){
????????????Dodge_moving_key[i]++;
????????}
????????else{
????????????Dodge_moving_key[i] = 0;
????????}
????}
????return 0;
}
int SelectOptionKey()
{
????char tmpKey[256];
????GetHitKeyStateAll(tmpKey);
?
????for (int i = 0; i < 256; i++){
????????if (tmpKey[i] != 0){
????????????selectOption_key[i]++;
????????}
????????else{
????????????selectOption_key[i] = 0;
????????}
????}
????return 0;
}
int AttackOptionKey()
{
????char tmpKey[256];
????GetHitKeyStateAll(tmpKey);
?
????for (int i = 0; i < 256; i++){
????????if (tmpKey[i] != 0){
????????????attackOption_key[i]++;
????????}
????????else{
????????????attackOption_key[i] = 0;
????????}
????}
????return 0;
}
int SkillOptionKey()
{
????char tmpKey[256];
????GetHitKeyStateAll(tmpKey);
?
????for (int i = 0; i < 256; i++){
????????if (tmpKey[i] != 0){
????????????skillOption_key[i]++;
????????}
????????else{
????????????skillOption_key[i] = 0;
????????}
????}
????return 0;
}
int ItemOptionKey()
{
????char tmpKey[256];
????GetHitKeyStateAll(tmpKey);
?
????for (int i = 0; i < 256; i++){
????????if (tmpKey[i] != 0){
????????????itemOption_key[i]++;
????????}
????????else{
????????????itemOption_key[i] = 0;
????????}
????}
????return 0;
}
?
// 화면 실행 함수들
void FirstMenu()
{
????printfDx("FirstMenu() Test...");
????DxLib_Init();
????int menu_background;
????menu_background = LoadGraph("image/callofduty_bg.png");
?
????int x = 300;??? int y = 240;
?
????int FontHandle;
?
????FontHandle = CreateFontToHandle(NULL, 25, 10);
?
????Menu MenuElement[MENU_NUM] = {
????????{ 100, 100, "DODGE" },????????? //0
????????{ 100, 150, "TETRIS" },???????? //1 
????????{ 100, 200, "Function Test" },? //2
????????{ 100, 250, "RPG Game" },?????? //3
????????{ 100, 300, "EXIT" },?????????? //4
????};
?
????///////////// 화면 출력 /////////////
????while (gpUpdateKey() == 0 && ScreenFlip() == 0 && ProcessMessage() == 0 && ClearDrawScreen() == 0) {
?
????????// TAB 입력시 프로그램 종료 
????????if (menu_key[KEY_INPUT_TAB]){
????????????menu_selectNum = MENU_NUM - 1;
????????}
????????sleep(50);
????????//Background 출력
????????DrawGraph(0, 0, menu_background, TRUE);
?
????????// 화면 사이즈 및 비트수 출력
????????int Sx, Sy, z;
????????GetScreenState(&Sx, &Sy, &z);
????????DrawFormatString(100, 400, White, "Screen Size : %d X %d / Bit: %d", Sx, Sy, z);
?
????????// 메뉴 화면 선택 및 출력 코드
????????if (menu_key[KEY_INPUT_UP]){
????????????menu_selectNum--;
????????????if (menu_selectNum < 0){
????????????????menu_selectNum = 0;
????????????}
????????}
????????if (menu_key[KEY_INPUT_DOWN]){
????????????menu_selectNum++;
????????????if (menu_selectNum >= MENU_NUM - 1){
????????????????menu_selectNum = MENU_NUM - 1;
????????????}
????????}
?
????????for (int i = 0; i < MENU_NUM; i++){
????????????if (i == menu_selectNum){
????????????????MenuElement[i].x = 80;
????????????}
????????????else
????????????????MenuElement[i].x = 100;
?
????????}
????????// 메뉴? 화면 출력 부분
????????for (int i = 0; i < MENU_NUM; i++){
????????????DrawStringToHandle(MenuElement[i].x, MenuElement[i].y, MenuElement[i].name, White, FontHandle);
????????}
?
????????// 메뉴 Start 선택 시 StartScreen() 함수 호출
????????if (menu_key[KEY_INPUT_RETURN]){??????? // Dodge
????????????if (menu_selectNum == 0){
????????????????DrawGraph(0, 0, menu_background, FALSE);
????????????????InitGraph();
????????????????ClearDrawScreen();
????????????????menu_selectNum = 0;
????????????????clsDx();
????????????????StartScreen();
????????????}
????????????else if (menu_selectNum == 1){????? // Tetris
????????????????clsDx();
????????????????menu_selectNum = 1;
????????????????ClearDrawScreen();
????????????????Tetris();
????????????}
????????????else if (menu_selectNum == 2){????? // Function Test
????????????????clsDx();
????????????????menu_selectNum = 2;
????????????????ClearDrawScreen();
????????????????MonsterApperance();
????????????}
????????????else if (menu_selectNum == 3){????? // MonsterHero
????????????????clsDx();
????????????????menu_selectNum = 3;
????????????????ClearDrawScreen();
????????????????MonsterHero();
????????????}
????????????else if (menu_selectNum == 4){????? // Exit
????????????????DxLib_End();
????????????}
????????}
????????// 메뉴 Exit 선택 프로그램 종료
????}
}
void StartScreen()
{
????DxLib_Init();
????char str[] = { "Dodge Game" };
????char str2[] = { "Dodge is just dodge from something WHITE!!" };
????printfDx("StartScreen() Test...");
?
????while (StartGpUpdateKey() == 0 && ScreenFlip() == 0 && ProcessMessage() == 0 && ClearDrawScreen() == 0) {
?
????????// Esc 입력시 
????????if (start_key[KEY_INPUT_TAB]){
????????????InitKeyInput();
????????????InitGraph();
????????????clsDx();
????????????ClearDrawScreen();
????????????FirstMenu();
????????}
?
????????SetBackgroundColor(0, 0, 0);
?
????????DrawString(100, 300, str, White);
????????DrawString(100, 350, str2, White);
?
????????DrawString(380, 430, "Press S Button To Continue", White);
?
????????if (CheckHitKey(KEY_INPUT_S)){
????????????InitGraph();
????????????clsDx();
????????????Dodge_level1();
????????}
????????/*
????????for (int i = 0; i < 3; i++){
????????SetBackgroundColor(0, 0, 0);
????????ScreenFlip();
????????ClearDrawScreen();
????????Sleep(100);
????????SetBackgroundColor(255, 255, 255);
????????}
????????*/
????}
}
void StartSkyrim()
{
????DxLib_Init();
????char str[] = { "Skyrim" };
????char str2[] = { "Dodge is just dodge from something WHITE!!" };
????printfDx("StartScreen() Test...");
?
????while (StartGpUpdateKey() == 0 && ScreenFlip() == 0 && ProcessMessage() == 0 && ClearDrawScreen() == 0) {
?
????????// Esc 입력시 
????????if (start_key[KEY_INPUT_TAB]){
????????????InitKeyInput();
????????????InitGraph();
????????????clsDx();
????????????ClearDrawScreen();
????????????FirstMenu();
????????}
?
????????SetBackgroundColor(0, 0, 0);
?
????????DrawString(100, 300, str, White);
????????DrawString(100, 350, str2, White);
?
????????DrawString(380, 430, "Press S Button To Continue", White);
?
????????if (CheckHitKey(KEY_INPUT_S)){
????????????InitGraph();
????????????clsDx();
????????????Skyrim();
????????}
????????/*
????????for (int i = 0; i < 3; i++){
????????SetBackgroundColor(0, 0, 0);
????????ScreenFlip();
????????ClearDrawScreen();
????????Sleep(100);
????????SetBackgroundColor(255, 255, 255);
????????}
????????*/
????}
}
void Game_End()
{
????DxLib_Init();
????while (ScreenFlip() == 0 && ProcessMessage() == 0 && ClearDrawScreen() == 0) {
????????SetBackgroundColor(0, 0, 0);
?
????????DrawString(280, 240, "Game Over...", White);
????????DrawString(400, 400, "Press S to Continue", White);
?
????????if (CheckHitKey(KEY_INPUT_S)){
????????????InitGraph();
????????????ClearDrawScreen();
????????????FirstMenu();
????????}
????}
}
void DodgeDraw()
{
????int bul;??????? // bullet 이미지 handle
????bul = LoadGraph("image/bul_test_small.png");
?????
????// 탄 출력 부분? 
????DrawGraph(bullet->bul_x, bullet->bul_y, bul, TRUE);
?
????// 공 1개씩 추가하는 부분
????Curr = Head;
????if (bulCount >= 1){
????????while (Curr->next != NULL){
????????????Curr->bul_x += Random(5) + 1;
????????????Curr->bul_y += Random(5) + 1;
?
????????????DrawGraph(Curr->bul_x, Curr->bul_y, bul, TRUE);
????????????Curr = Curr->next;
????????}
????}
}
void Dodge_level1()
{
????printfDx("Dodge_level1() Test...\n");
????DxLib_Init();
?
????int airplane;?? // airplane image handle
????airplane = LoadGraph("image/airplane_pic.jpg");
?
????int x = 500;??? int y = 400; // airplane 좌표
????bulCount = 0;
????check = False;
?
????bullet = (BULLET*)malloc(sizeof(BULLET));
????bullet->bul_x = 320;
????bullet->bul_y = 160;
????bullet->next = NULL;
????bullet->prev = NULL;
?
????float temp_x = 4;
????float temp_y = 4;
?
????int option_selectNum = 1;
?
????int speed = 15;
????int Font1;????? // String Font
????Font1 = CreateFontToHandle(NULL, 20, 10);
?
????EXIT_OPTION ExitElement[3] = {
????????{ 230, 225, "Exit the Game?" }, // 0
????????{ 265, 250, "Yes" },??????????? // 1
????????{ 325, 250, "No" },???????????? // 2
????};
?????
????while (DodgeMovingGpUpdateKey() == 0 && ScreenFlip() == 0 && ProcessMessage() == 0 && ClearDrawScreen() == 0) {
????????SetBackgroundColor(0, 0, 0);
?
????????// Esc키 누르면 check를 트루로
????????if (CheckHitKey(KEY_INPUT_TAB)){
????????????check = True;
????????}
?
????????// DodgeDraw 호출 및 airplane image handler 출력
????????DrawGraph(x - 25, y - 25, airplane, TRUE);
?
????????// 비행기 및 탄 코드 부분
????????if (check == False){
????????????// 탄 좌표 및 출력 및 이동 부분
????????????bullet->bul_x += temp_x;
????????????bullet->bul_y += temp_y;
?
????????????// bullet이 가진 지역변수 입력 x축
????????????if (bullet->bul_x > 680 || bullet->bul_x < 0){
????????????????printfDx("X Line Function\n");
????????????????bullet = (BULLET*)malloc(sizeof(BULLET));
????????????????bullet->bul_x = 320;
????????????????bullet->bul_y = 160;
????????????????bullet->next = NULL;
????????????????bullet->prev = NULL;
????????????????bulCount++;
?
????????????????if (Head == NULL){
????????????????????Head = bullet;
????????????????????Curr = bullet;
????????????????????Tail = bullet;
????????????????}
????????????????else{
????????????????????bullet->prev = Curr;
????????????????????Curr->next = bullet;
????????????????????Curr = bullet;
????????????????????Tail = bullet;
????????????????}
????????????????printfDx("Before:(%f/%f)\n", temp_x, temp_y);
?
????????????????temp_x = Random(speed) - Random(speed);
????????????????temp_y = Random(speed) - Random(speed);
????????????????if (temp_x == 0)
????????????????????temp_x = Random(3) - 5;
????????????????else if (temp_x < 2 && temp_x > 0)
????????????????????temp_x += 2;
????????????????else if (temp_x > -2 && temp_x < 0)
????????????????????temp_x -= 2;
????????????????if (temp_y == 0)
????????????????????temp_y = Random(3) - 5;
????????????????else if (temp_y < 2 && temp_y >0)
????????????????????temp_y += 2;
????????????????else if (temp_y > -2 && temp_y < 0)
????????????????????temp_y -= 2;
?
????????????????printfDx("After:(%f/%f)\n", temp_x, temp_y);
????????????}
?
????????????// bullet이 가진 지역변수 입력? y축
????????????else if (bullet->bul_y > 480 || bullet->bul_y < 0){
????????????????printfDx("Y Line Function\n");
????????????????bullet = (BULLET*)malloc(sizeof(BULLET));
????????????????bullet->bul_x = 320;
????????????????bullet->bul_y = 160;
????????????????bullet->next = NULL;
????????????????bullet->prev = NULL;
????????????????bulCount++;
?
????????????????if (Head == NULL){
????????????????????Head = bullet;
????????????????????Curr = bullet;
????????????????????Tail = bullet;
????????????????}
????????????????else{
????????????????????bullet->prev = Curr;
????????????????????Curr->next = bullet;
????????????????????Curr = bullet;
????????????????????Tail = bullet;
????????????????}
????????????????printfDx("Before:(%f/%f)\n", temp_x, temp_y);
?????????????????
????????????????temp_x = Random(speed) - Random(speed);
????????????????temp_y = Random(speed) - Random(speed);
????????????????if (temp_x == 0)
????????????????????temp_x = Random(3) + 2;
????????????????else if (temp_x < 2 && temp_x > 0)
????????????????????temp_x += 2;
????????????????else if (temp_x > -2 && temp_x < 0)
????????????????????temp_x -= 2;
????????????????if (temp_y == 0)
????????????????????temp_y = Random(3) + 2;
????????????????else if (temp_y < 2 && temp_y >0)
????????????????????temp_y += 2;
????????????????else if (temp_y > -2 && temp_y < 0)
????????????????????temp_y -= 2;
?
????????????????printfDx("After:(%f/%f)\n", temp_x, temp_y);
????????????}
?
????????????// bullet Draw Function Call
????????????DodgeDraw();
?
????????????// airplane 이동 부분
????????????if (Dodge_moving_key[KEY_INPUT_RIGHT]){
????????????????x = x + 8;
????????????????if (x > 640){
????????????????????x = 0;
????????????????}
????????????}
????????????else if (Dodge_moving_key[KEY_INPUT_LEFT]){
????????????????x = x - 8;
????????????????if (x < 0){
????????????????????x = 640;
????????????????}
????????????}
????????????else if (Dodge_moving_key[KEY_INPUT_UP]){
????????????????y = y - 8;
????????????????if (y < 0){
????????????????????y = 480;
????????????????}
????????????}
????????????else if (Dodge_moving_key[KEY_INPUT_DOWN]){
????????????????y = y + 8;
????????????????if (y > 480){
????????????????????y = 0;
????????????????}
????????????}
?
????????????// 비행기랑 탄이랑 충돌 하면 ㅠㅠ 겜오바
????????????if (x < bullet->bul_x + 25 && x > bullet->bul_x - 25){
????????????????if (y < bullet->bul_y + 25 && y > bullet->bul_y - 25){
????????????????????InitGraph();
????????????????????ClearDrawScreen();
????????????????????free(bullet);
????????????????????Game_End();
????????????????}
????????????}
????????}
?
????????// 종료(yes,no)창 
????????if (DodgeGpUpdateKey() == 0 && check == True){
????????????// 출력
????????????for (int i = 0; i < MENU_NUM; i++){
????????????????DrawStringToHandle(ExitElement[i].x, ExitElement[i].y, ExitElement[i].name, White, Font1);
????????????}
????????????// 왼쪽 이동
????????????if (Dodge_key[KEY_INPUT_LEFT]){
????????????????option_selectNum--;
????????????????if (option_selectNum <= 1){
????????????????????option_selectNum = 1;
????????????????}
????????????}
????????????// 오른쪽이동
????????????if (Dodge_key[KEY_INPUT_RIGHT]){
????????????????option_selectNum++;
????????????????if (option_selectNum > 2){
????????????????????option_selectNum = 2;
????????????????}
????????????}
????????????// 이동
????????????for (int i = 1; i <= 2; i++){
????????????????if (i == option_selectNum)
????????????????????ExitElement[i].y = 260;
????????????????else
????????????????????ExitElement[i].y = 250;
????????????}
????????????// yes 선택시
????????????if (Dodge_key[KEY_INPUT_RETURN] && option_selectNum == 1){
????????????????InitGraph();
????????????????clsDx();
????????????????ClearDrawScreen();
????????????????check = False;
????????????????free(bullet);
????????????????FirstMenu();
????????????}
????????????// no 선택시
????????????if (Dodge_key[KEY_INPUT_RETURN] && option_selectNum == 2){
????????????????check = False;
????????????}
????????}
?????????
????????/*
????????if (check = Clear){
????????????Curr = Head;
????????????printfDx("1pos:(%f,%f,)", Curr->bul_x, Curr->bul_y);
????????????while (Curr->next != NULL){
????????????????Curr->next = Curr;
????????????????printfDx("1pos:(%f,%f,)", Curr->bul_x, Curr->bul_y);
????????????}
????????}*/
????}
?
}
void Tetris()
{
????/*Random 메소드 사용해서 도형이 랜덤으로 나오도록 하면 될듯?? 
????먼저 박스 만들어 놓고??*/
????printfDx("Tetris() Test...");
????DxLib_Init();
????int check = False;
?
????while (TestrisMovingKey() == 0 && ScreenFlip() == 0 && ProcessMessage() == 0 && ClearDrawScreen() == 0) {
?
????????if (testris_key[KEY_INPUT_TAB]){
????????????InitGraph();
????????????DxLib_End();
????????}
????}
}
?
// Map 전역변수
#define MH_MAP_SIZE 30 
#define MH_MAP_WIDTH 23
#define MH_MAP_HEIGHT 20
#define HUNT_OPTION 4
int testX = 1, testY = 1;
int char_count = 8;
int monsterApper;
int test;
int flipSpeed = 300;
int screenCount = 0;
?
// MonsterApperance()에서 사용
int selectOptionNum = 0;
int attackOptionNum = 0;
?
// MonsterApperance()에서 박스 체크를 위해서
int flip_check = False;
int attack_check = False;
int skill_check = False;
int item_check = False;
?
// 총 및 현재 Hp와 Mp의 변수 선언 및 정의
float fullHp = 100, currentHp = 50;
float fullMp = 20, currentMp = 10;
float enemy_fullHp = 50, enemy_currentHp = 25;
float enemy_fullMp = 20, enemy_currentMp = 10;
?
// Level 전역변수
int heroLevel = 1;
int enemy_hegeonLevel = 1;
?
// 맵 그립 
int TestMapData[MH_MAP_HEIGHT][MH_MAP_WIDTH] =
{?? //0? 1? 2? 3? 4? 5? 6? 7? 8? 9? 10 11 12 13 14 15 16 17 18 19 20 21 22
????{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, //? 0 
????{ 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,11,11,11,11,11, 0,10,10,10,10,10,10, 0 }, //? 1
????{ 0, 0, 1, 1, 1, 0, 0, 0, 0, 0,11,11,11,11,11, 0,10,10,10,10,10,10, 0 }, //? 2
????{ 0, 0, 1, 0, 1, 0, 0, 0, 0, 0,11,11,11,11,11, 0,10,10,10,10,10,10, 0 }, //? 4
????{ 0, 1, 1, 0, 1, 0, 0, 1, 1, 0,11,11,11,11,11, 0,10,10,10,10,10,10, 0 }, //? 5
????{ 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0,10,10,10, 0 }, //? 6
????{ 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0 }, //? 7
????{ 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0 }, //? 8
????{ 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0 }, //? 9
????{ 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0 }, // 10
????//8
????{ 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0 }, // 11
????{ 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0 }, // 12
????{ 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0 }, // 13
????{ 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0 }, // 14
????{ 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0 }, // 15
????{ 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0 }, // 16
????{ 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0 }, // 17
????{ 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0 }, // 18
????{ 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0 }, // 19
????{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, // 20
}; 
void HeroAttack()
????{
????????// attack Effect image handler declare
????????int attack_scratchEffect_handle = LoadGraph("image/scratch_effect.jpg");
????????int attack_tackleEffect_handle = LoadGraph("image/tackle_effect.jpg");
?
????????AttackName attackName[4]{
????????????{ 350, 380, "Tackle"},????? // 0
????????????{ 350, 410, "Scratch" },??????? // 1
????????????{ 450, 380, "Punch" },// 2
????????????{ 450, 410, "?????" },????? // 3
????????};
?
????????// Attack 선택 창 켜기
????????if (attack_check == True){
????????????AttackOptionKey();
????????????// attack 선택 창 출력
????????????DrawBox(320, 350, 590, 450, Black, TRUE);
?
????????????for (int i = 0; i < 4; i++){
????????????????// Attack name 출력
????????????????DrawString(attackName[i].x, attackName[i].y, attackName[i].name, White);
????????????}
?
????????????// 키이동 활성화 함수 호출및 효과 부여
????????????if (attackOption_key[KEY_INPUT_DOWN]){
????????????????if (attackOptionNum == 0){
????????????????????attackOptionNum = 1;
????????????????}
????????????????if (attackOptionNum == 2)
????????????????????attackOptionNum = 3;
????????????}
????????????if (attackOption_key[KEY_INPUT_UP]){
????????????????if (attackOptionNum == 1){
????????????????????attackOptionNum = 0;
????????????????}
????????????????if (attackOptionNum == 3){
????????????????????attackOptionNum = 2;
????????????????}
????????????}
????????????if (attackOption_key[KEY_INPUT_RIGHT]){
????????????????if (attackOptionNum == 0){
????????????????????attackOptionNum = 2;
????????????????}
????????????????if (attackOptionNum == 1){
????????????????????attackOptionNum = 3;
????????????????}
????????????}
????????????if (attackOption_key[KEY_INPUT_LEFT]){
????????????????if (attackOptionNum == 2){
????????????????????attackOptionNum = 0;
????????????????}
????????????????if (attackOptionNum == 3){
????????????????????attackOptionNum = 1;
????????????????}
????????????}
????????????sleep(70);
?
????????????// 키 출력 효과 부여
????????????for (int j = 0; j < 4; j++){
????????????????if (j == 0){
????????????????????if (j == attackOptionNum){
????????????????????????DrawString(330, 380, "->", White);
????????????????????}
????????????????}
????????????????if (j == 1){
????????????????????if (j == attackOptionNum){
????????????????????????DrawString(330, 410, "->", White);
????????????????????}
????????????????}
????????????????if (j == 2){
????????????????????if (j == attackOptionNum){
????????????????????????DrawString(430, 380, "->", White);
????????????????????}
????????????????}
????????????????if (j == 3){
????????????????????if (j == attackOptionNum){
????????????????????????DrawString(430, 410, "->", White);
????????????????????}
????????????????}
????????????}
????????????// tackle
????????????if (attackOption_key[KEY_INPUT_SPACE] && attackOptionNum == 0){
????????????????DrawGraph(400, 50, attack_tackleEffect_handle, TRUE);
????????????????sleep(100);
????????????????attack_check = False;
????????????}
?
????????????// scratch 
????????????if (attackOption_key[KEY_INPUT_SPACE] && attackOptionNum == 1){
????????????????DrawGraph(400, 50, attack_scratchEffect_handle, TRUE);
????????????????sleep(100);
????????????????attack_check = False;
????????????}
?
????????????//punch
????????????if (attackOption_key[KEY_INPUT_SPACE] && attackOptionNum == 2){
????????????????DrawString(400, 50, "Punch Image Need", Red);
????????????????sleep(100);
????????????????attack_check = False;
????????????}
?
????????????printfDx("attackOptionNum : %d\nattac_check : %d\n", attackOptionNum, attack_check);
????????}
?
????????// Attack 선택창 끄기
????????if (attackOption_key[KEY_INPUT_Z]){
????????????clsDx();
????????????attack_check = False;
????????}
????}
void HeroSkill()
????{
????????DrawBox(320, 350, 590, 450, Black, TRUE);
????????DrawString(400, 400, "Skil Test", White);
?
????????if (CheckHitKey(KEY_INPUT_Z)){
????????????clsDx();
????????????skill_check = False;
????????}
????}
void HeroItem()
????{
????????DrawBox(320, 350, 590, 450, Black, TRUE);
????????DrawString(400, 400, "Item Test", White);
?
?
????????if (CheckHitKey(KEY_INPUT_Z)){
????????????clsDx();
????????????item_check = False;
????????}
????}
void MonsterApperance()
{
????printfDx("MonsterApperance() Test...\n");
?????
????// 인트형인 Hp와 Mp를 캐릭터형으로 바꾸어서 출력할수 있도록 선언
????char chFullHp[10] = {};
????char chCurrHp[10] = {};
????char chFullMp[10] = {};
????char chCurrMp[10] = {};
????char chEnemy_FullHp = {};
????char chEnemy_CurrHp = {};
?????
????int printHp = (200 * (currentHp / fullHp)) + 100;
????int printMp = (200 * (currentMp / fullMp)) + 100;
????int print_enemyHp = (400 * (enemy_currentHp / enemy_fullHp)) + 100;
?????
????/*
????int selectFont = CreateFontToHandle(NULL, 20, 9, DX_FONTTYPE_NORMAL);
????*/
?
????// 너무 빤짝빤짝 눈이부셔
????int background_black_handle, background_white_handle;
????background_black_handle = LoadGraph("image/background_black.jpg");
????background_white_handle = LoadGraph("image/background_white.jpg");
?
?
????// Level 저장
????char chHeroLevel[3] = {};
????char chEnemy_hugeonLevel[3] = {};
?
????// Hero & monster image handlers
????int monster_handle1 = LoadGraph("image/monster_hugeon.jpg");
????int heroBack_handle = LoadGraph("image/heroBack.jpg");
?
????// 인트형을 캐릭터형으로 10진수로 변환
????_itoa_s(fullHp, chFullHp, 10);
????_itoa_s(currentHp, chCurrHp, 10);
????_itoa_s(fullMp, chFullMp, 10);
????_itoa_s(currentMp, chCurrMp, 10);
????_itoa_s(heroLevel, chHeroLevel, 10);
????_itoa_s(enemy_hegeonLevel, chEnemy_hugeonLevel, 10);
?
????Status status[2]{
????????{ 100, 360, "HP" },???? // 0
????????{ 100, 405, "MP" },???? // 1
????};
????SelectOption selectOption[HUNT_OPTION]{
????????{ 370, 370, "Attack"},? // 0
????????{ 480, 370, "Skill" },? // 1
????????{ 370, 410, "Item" },?? // 2
????????{ 480, 410, "Run" },??? // 3 
????};
?
????while (ProcessMessage() == 0) {
????????if (CheckHitKey(KEY_INPUT_5)){
????????????flip_check = False;
????????}
????????// 화면 깜박깜박깜박하네영 왜 안하냐?? ㅠㅠ
????????if (flip_check == False){
????????????// 깜박이는 부분에 WaitTimer 값 설정
????????????DrawGraph(0, 0, background_black_handle, TRUE);
????????????WaitTimer(flipSpeed);
?????????
????????????DrawGraph(0, 0, background_white_handle, TRUE);
????????????WaitTimer(flipSpeed);
?????????????
????????????ClearDrawScreen();
?????????????
????????????screenCount++;
????????????flipSpeed -= 35;
?
????????????printfDx("FlipSpeed : %d\n", flipSpeed);
????????????printfDx("ScreenCount : %d\n", screenCount);
?
????????????// screenCount 값만큼 깜박이고 끝나면 MonseterApperance호출
????????????if (screenCount == 10)
????????????{
????????????????flip_check = True;
????????????????// 초기화
????????????????flipSpeed = 300;
????????????????screenCount = 0;
?????????????????
????????????????printfDx("\n---Correct Variable---\nFlipSpeed : %d\n", flipSpeed);
????????????????printfDx("ScreenCount : %d\n", screenCount);
????????????}
????????????ScreenFlip();
????????}
?
????????// 화면 깜박이 끝나면
????????if (flip_check == True){
????????????SelectOptionKey();
????????????// 배경 하양하양
????????????DrawGraph(0, 0, background_white_handle, TRUE);
?
????????????// 선택창 구분 및 생성
????????????DrawBox(50, 350, 590, 450, Black, False);
????????????DrawLine(320, 350, 320, 450, Black, 1);
?
????????????// HP, MP 글씨 출력
????????????for (int i = 0; i < 2; i++){
????????????????DrawString(status[i].x, status[i].y, status[i].name, Black);
????????????}
?
????????????// Hero Level 출력
????????????DrawString(250, 360, "Lv.", Black);
????????????DrawString(290, 360, chHeroLevel, Black);
?????????????
????????????// Hero HP 출력
????????????DrawString(130, 360, chCurrHp, Black);
????????????DrawString(155, 360, "/", Black);
????????????DrawString(170, 360, chFullHp, Black);
????????????DrawBox(100, 380, 300, 395, Black, True);
????????????DrawBox(100, 380, printHp, 395, Red, True);
?????????????
????????????// Hero Mp 출력
????????????DrawString(130, 405, chCurrMp, Black);
????????????DrawString(155, 405, "/", Black);
????????????DrawString(170, 405, chFullMp, Black);
????????????DrawBox(100, 425, 300, 440, Black, True);
????????????DrawBox(100, 425, printMp, 440, GetColor(0,0,255), True);
?
????????????// Enemy Level 출력
????????????DrawString(350, 25, "Lv.", Black);
????????????DrawString(390, 25, chEnemy_hugeonLevel, Black);
?
????????????// Enemy HP 출력
????????????DrawString(205, 25, "HP", Black);
????????????DrawBox(200, 45, 400, 60, Black, True);
????????????DrawBox(200, 45, print_enemyHp, 60, Red, True);
?
????????????// 선택 창 글씨 출력
????????????for (int j = 0; j < 4; j++){
????????????????DrawString(selectOption[j].x, selectOption[j].y, selectOption[j].name,Black);
????????????}
?
????????????// 선택창 선택 이동 효과
????????????if (selectOption_key[KEY_INPUT_UP]){
????????????????if (selectOptionNum == 2)
????????????????????selectOptionNum = 0;
????????????????if (selectOptionNum == 3)
????????????????????selectOptionNum = 1;
????????????}
????????????if (selectOption_key[KEY_INPUT_DOWN]){
????????????????if (selectOptionNum == 0)
????????????????????selectOptionNum = 2;
????????????????if (selectOptionNum == 1)
????????????????????selectOptionNum = 3;
????????????}
????????????if (selectOption_key[KEY_INPUT_LEFT]){
????????????????if (selectOptionNum == 1)
????????????????????selectOptionNum = 0;
????????????????if (selectOptionNum == 3)
????????????????????selectOptionNum = 2;
????????????}
????????????if (selectOption_key[KEY_INPUT_RIGHT]){
????????????????if (selectOptionNum == 0)
????????????????????selectOptionNum = 1;
????????????????if (selectOptionNum == 2)
????????????????????selectOptionNum = 3;
????????????}
????????????sleep(70);
?
????????????// Monster image handle code
????????????DrawGraph(400, 50, monster_handle1, TRUE);
????????????DrawGraph(75, 150, heroBack_handle, TRUE);
?
????????????// 선택창 선택 이동 효과
????????????for (int i = 0; i < HUNT_OPTION; i++){
????????????????if (i == 0){
????????????????????if (i == selectOptionNum){
????????????????????????//DrawStringToHandle(350, 370, selectOption[i].name, Black, selectFont);
????????????????????????DrawString(350, 370, "->", Black);
????????????????????}
????????????????}
????????????????else if (i == 2){
????????????????????if (i == selectOptionNum){
????????????????????????DrawString(350, 410, "->", Black);
????????????????????}
????????????????}
????????????????else if (i == 1){
????????????????????if (i == selectOptionNum){
????????????????????????DrawString(460, 370, "->", Black);
????????????????????}
????????????????}
????????????????else if (i == 3){
????????????????????if (i == selectOptionNum){
????????????????????????DrawString(460, 410, "->", Black);
????????????????????}
????????????????}
????????????}
????????????// attack 실행
????????????if (attack_check == False && selectOptionNum == 0 && selectOption_key[KEY_INPUT_SPACE]){??? // Attack
????????????????attack_check = True;
????????????}?? 
????????????????if (attack_check == True)
????????????????{
????????????????????//clsDx();
????????????????????HeroAttack();
????????????????}
?
????????????// skill 실행
????????????if (skill_check == False && selectOptionNum == 1 && selectOption_key[KEY_INPUT_SPACE]){
????????????????skill_check = True;
?????????????????
????????????}
????????????????if (skill_check == True){
????????????????????//clsDx();
????????????????????HeroSkill();
????????????????}
?
????????????// item 실행
????????????if (item_check == False && selectOptionNum == 2 && selectOption_key[KEY_INPUT_SPACE]){
????????????????item_check = True;
????????????}
????????????????if (item_check == True){
????????????????????//clsDx();
????????????????????HeroItem();
????????????????}
?
????????????// Run 실행
????????????if (attack_check == False && selectOptionNum == 3 && selectOption_key[KEY_INPUT_SPACE]){??? // Run
????????????????//clsDx();
?????????????????
????????????????ClearDrawScreen();
????????????????selectOptionNum = 0;
????????????????monsterApper = 0;
????????????????MonsterHero();
????????????}
?????????????
????????????ScreenFlip();
?????????????
????????}
?????????
?????????
????}
}
void MonsterHeroDrawMap()
{
????//printfDx("MonsterHeroDrawMap() executed...\n");
?
????int MapDrawPointX, MapDrawPointY; // 그리기지도 좌표 값
????int DrawMapChipNumX, DrawMapChipNumY; // 그리기지도 칩의 수
????DrawMapChipNumX = 640 / MH_MAP_SIZE + 1;
????DrawMapChipNumY = 480 / MH_MAP_SIZE + 1;
????MapDrawPointX = testX - DrawMapChipNumX / 2;
????MapDrawPointY = testY - DrawMapChipNumY / 2;
?
????// 맵 외곽 이미지 핸들러
????int outline_handle = LoadGraph("image/skyrim_outline.jpg");
?
????// 캐릭터 16등분 이미지 핸들러
????int character_handle[16];
????LoadDivGraph("image/divide_pic.png", 16, 4, 4, 30, 30, character_handle);
?
????// 집 이미지 핸들러 
????int house_handle1[20], house_handle2[30];
????LoadDivGraph("image/skyrim_house1.jpg", 20, 5, 4, 30, 30, house_handle1);
????int handle1_count = 0;
?
????LoadDivGraph("image/skyrim_house2.jpg", 30, 6, 5, 30, 30, house_handle2);
????int handle2_count = 0;
?
????for (int i = 0; i <DrawMapChipNumY; i++)
????{
????????for (int j = 0; j <DrawMapChipNumX; j++)
????????{
????????????// 이동중에도 이미지가 나오도록
????????????if (j + MapDrawPointX <0 || i + MapDrawPointY <0 ||
????????????????j + MapDrawPointX >= MH_MAP_WIDTH || i + MapDrawPointY >= MH_MAP_HEIGHT) 
????????????????continue;
?
????????????// 0은 외곽처리
????????????if (TestMapData[i + MapDrawPointY][j + MapDrawPointX] == 0)
????????????{
????????????????DrawGraph(j * MH_MAP_SIZE, i * MH_MAP_SIZE, outline_handle, TRUE);
?????????????????
????????????????// 랜덤 확률로 몬스터 출현하도록
????????????????if (monsterApper == 19){
????????????????????clsDx();
?????????????????????
????????????????????flip_check = False;
????????????????????printfDx("===MonsterApper===\nFlipSpeed : %d\n", flipSpeed);
????????????????????printfDx("ScreenCount : %d\n", screenCount);
????????????????????MonsterApperance();
????????????????}
????????????}
?
????????????// TestMapData의 행렬값이 1이면 하얀색 박스처리
????????????if (TestMapData[i + MapDrawPointY][j + MapDrawPointX] == 1)
????????????{
????????????????DrawBox(j * MH_MAP_SIZE, i * MH_MAP_SIZE,
????????????????????j * MH_MAP_SIZE + MH_MAP_SIZE, i * MH_MAP_SIZE + MH_MAP_SIZE,
????????????????????White, TRUE);
????????????}
?
????????????// 10이면 house_handle2 처리
????????????if (TestMapData[i + MapDrawPointY][j + MapDrawPointX] == 10){
????????????????DrawGraph(j * MH_MAP_SIZE, i * MH_MAP_SIZE, house_handle2[handle2_count], TRUE);
????????????????handle2_count++;
????????????????if (handle2_count == 24){
????????????????????handle2_count = 27;
????????????????}
????????????}
?
????????????// 11이면 house_handle1 처리
????????????if (TestMapData[i + MapDrawPointY][j + MapDrawPointX] == 11){
????????????????DrawGraph(j * MH_MAP_SIZE, i * MH_MAP_SIZE, house_handle1[handle1_count], TRUE);
????????????????handle1_count++;
????????????}
????????}
????}
?
????// 캐릭터 이미지 그리기
????DrawGraph((testX - MapDrawPointX)*MH_MAP_SIZE, (testY - MapDrawPointY)*MH_MAP_SIZE, character_handle[char_count], TRUE);
}
void MonsterHero()
{
????DxLib_Init();
????printfDx("MonsterHero() Test...\n");
????int oldX, oldY;
?
????// 백그라운드 이미지 핸들러
????int background_handle;
????background_handle = LoadGraph("image/skyrim_bg.png");
?
????monsterApper = 0;
?
????SetDrawScreen(DX_SCREEN_BACK);
?
????while (ProcessMessage() == 0) {
????????SkyrimCharacterMovingKey();
????????if (character_key[KEY_INPUT_TAB]){
????????????//clsDx();
????????????InitGraph();
????????????ClearDrawScreen();
????????????FirstMenu();
????????}
????????for (int i = 0; i < 680 / 8; i++){
????????????DrawGraph(i * 8, 0, background_handle, TRUE);
????????}
????????oldX = testX;
????????oldY = testY;
?
????????// 캐릭터 이동
????????if (character_key[KEY_INPUT_UP]){
????????????testY -= 1;
????????????char_count = 0;
????????????monsterApper = Random(20);
????????}
????????if (character_key[KEY_INPUT_DOWN]){
????????????testY += 1;
????????????char_count = 8;
????????????monsterApper = Random(20);
????????}
????????if (character_key[KEY_INPUT_LEFT]){
????????????testX -= 1;
????????????char_count = 4;
????????????monsterApper = Random(20);
????????}
????????if (character_key[KEY_INPUT_RIGHT]){
????????????testX += 1;
????????????char_count = 12;
????????????monsterApper = Random(20);
????????}
?
????????if (TestMapData[testY][testX] != 1){
????????????testX = oldX;
????????????testY = oldY;
????????}
?
????????MonsterHeroDrawMap();
????????ScreenFlip();
????????WaitTimer(50);
?
????}
}
int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
{
????ChangeWindowMode(TRUE);
?
????DxLib_Init();
????SetMainWindowText("GameLand OF SangGi");
?
????FirstMenu();
?
????DxLib_End();
?
????return 0;
}
?
// Map 전역변수
#define MAP_SIZE 32 
#define MAP_WIDTH 20 
#define MAP_HEIGHT 16 
int playerX, playerY;
?
// 맵 그립 
int MapData[MAP_HEIGHT][MAP_WIDTH] =
{?? //0? 1? 2? 3? 4? 5? 6? 7? 8? 9? 10 11 12 13 14 15 16 17 18 19
????{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
????{ 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 },
????{ 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0 },
????{ 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0 },
????{ 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0 },
????{ 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0 },
????{ 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0 },
????{ 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0 },
????//8
????{ 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0 },
????{ 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0 },
????{ 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0 },
????{ 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0 },
????{ 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0 },
????{ 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 },
????{ 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 },
????{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
};
void DrawMap()
{
????int MapDrawPointX, MapDrawPointY; // 그리기지도 좌표 값
????int DrawMapChipNumX, DrawMapChipNumY; // 그리기지도 칩의 수
????DrawMapChipNumX = 640 / MAP_SIZE + 1;
????DrawMapChipNumY = 480 / MAP_SIZE + 1;
????MapDrawPointX = playerX - DrawMapChipNumX / 2;
????MapDrawPointY = playerY - DrawMapChipNumY / 2;
?
????int character_img[16];
????LoadDivGraph("image/divide_pic.png", 16, 4, 4, 32, 32, character_img);
?
????for (int i = 0; i <DrawMapChipNumY; i++)
????{
????????for (int j = 0; j <DrawMapChipNumX; j++)
????????{
????????????if (j + MapDrawPointX <0 || i + MapDrawPointY <0 ||
????????????????j + MapDrawPointX >= MAP_WIDTH || i + MapDrawPointY >= MAP_HEIGHT) continue;
?
????????????if (MapData[i + MapDrawPointY][j + MapDrawPointX] == 0)
????????????{
????????????????DrawBox(j * MAP_SIZE, i * MAP_SIZE,
????????????????????j * MAP_SIZE + MAP_SIZE, i * MAP_SIZE + MAP_SIZE,
????????????????????Black, TRUE);
????????????}
????????}
????}
????DrawBox((playerX - MapDrawPointX)*MAP_SIZE, (playerY - MapDrawPointY)*MAP_SIZE,
????????(playerX - MapDrawPointX + 1)*MAP_SIZE, (playerY - MapDrawPointY + 1)*MAP_SIZE, Green, TRUE);
}
void Skyrim()
{
????DxLib_Init();
????printfDx("Skyrim() Test...");
????int oldX, oldY;
?
????playerX = 1;
????playerY = 1;
?
????SetDrawScreen(DX_SCREEN_BACK);
?
????while (SkyrimCharacterMovingKey() == 0 && ProcessMessage() == 0) {
????????SetBackgroundColor(255, 255, 255);
????????if (CheckHitKey(KEY_INPUT_TAB)){
????????????InitGraph();
????????????clsDx();
????????????FirstMenu();
????????}
????????ClearDrawScreen();
?
?
????????oldX = playerX;
????????oldY = playerY;
?
????????if (character_key[KEY_INPUT_UP]){
????????????playerY -= 1;
????????}
????????if (character_key[KEY_INPUT_DOWN]){
????????????playerY += 1;
????????}
????????if (character_key[KEY_INPUT_LEFT]){
????????????playerX -= 1;
????????}
????????if (character_key[KEY_INPUT_RIGHT]){
????????????playerX += 1;
????????}
?
????????if (MapData[playerY][playerX] == 0){
????????????playerX = oldX;
????????????playerY = oldY;
????????}
?
????????DrawMap();
?
????????ScreenFlip();
?
????????WaitTimer(100);
?
????}
}