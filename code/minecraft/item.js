(function (global) {	'use strict';	// shim layer with setTimeout fallback	var requestAnimFrame = (function () {		return window.requestAnimationFrame       || 		       window.webkitRequestAnimationFrame || 		       window.mozRequestAnimationFrame    || 		       window.oRequestAnimationFrame      || 		       window.msRequestAnimationFrame     || 		       function(/* function */ callback, /* DOMElement */ element){		           window.setTimeout(callback, 1000 / 60);		       };	}());		function getMaterial (img, trans) {		var material = new THREE.MeshBasicMaterial({			map: new THREE.Texture(				img,				new THREE.UVMapping(),				THREE.ClampToEdgeWrapping,				THREE.ClampToEdgeWrapping,				THREE.NearestFilter,				THREE.NearestFilter,				(trans? THREE.RGBAFormat : THREE.RGBFormat)			),			transparent: trans		});		material.map.needsUpdate = true;		console.log(material);				return material;	};	function uvmap (mesh, face, x, y, w, h, rotateBy) {		if(!rotateBy) rotateBy = 0;		var uvs = mesh.geometry.faceVertexUvs[0][face];		var tileU = x;		var tileV = y;		var tileUvWidth = 1/256;		var tileUvHeight = 1/256;				uvs[ (0 + rotateBy) % 4 ].u = tileU * tileUvWidth;		uvs[ (0 + rotateBy) % 4 ].v = tileV * tileUvHeight;		uvs[ (1 + rotateBy) % 4 ].u = tileU * tileUvWidth;		uvs[ (1 + rotateBy) % 4 ].v = tileV * tileUvHeight + h * tileUvHeight;		uvs[ (2 + rotateBy) % 4 ].u = tileU * tileUvWidth + w * tileUvWidth;		uvs[ (2 + rotateBy) % 4 ].v = tileV * tileUvHeight + h * tileUvHeight;		uvs[ (3 + rotateBy) % 4 ].u = tileU * tileUvWidth + w * tileUvWidth;		uvs[ (3 + rotateBy) % 4 ].v = tileV * tileUvHeight;	};		function createItem (id) {				var imgdata = itemsc.getImageData(Math.floor(id % 16)*16, Math.floor(id / 16)*16, 16, 16);		var imd = imgdata.data;				var geo = new THREE.Geometry();				for(var x=0; x < 16; x++) {			for(var y=0; y < 16; y++) {				if(imd[(x+y*16)*4+3] === 0) {					continue;				}								var voxel = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1), itemsMaterial);				for(var i=0; i < 6; i++) {					uvmap(voxel, i, Math.floor(id % 16)*16+x, Math.floor(id / 16)*16+y, 1, 1);				}								voxel.position.x = x-8;				voxel.position.y = -(y-8);				THREE.GeometryUtils.merge(geo, voxel);			}		}				var mesh = new THREE.Mesh(geo,itemsMaterial );				return mesh;	};		function render () {		requestAnimFrame(render, renderer.domElement);				var time = (Date.now() - startTime)/1000;				camera.position.x = -Math.cos(time/2);		camera.position.z = -Math.sin(time/2);		camera.position.y = 0.25*Math.sin(time);		camera.position.setLength(150-Math.cos(time)*50);		camera.lookAt(new THREE.Vector3(0, Math.cos(time/3)*50, 0));				var rot = time*1.5;				for(var i=0; i < itemsmeshes.length; i++) {			itemsmeshes[i].rotation.y = (i%2 === 0 ? -1 : 1)*rot+i;		}				renderer.render(scene, camera);	};		var startTime = Date.now();			var container = global.document.querySelector('#container');		var itemscanvas = global.document.createElement('canvas');	itemscanvas.width = 256;	itemscanvas.height = 256;	var itemsc = itemscanvas.getContext('2d');	var itemsMaterial = getMaterial(itemscanvas, true);		var w = global.innerWidth, h = global.innerHeight;		var scene = new THREE.Scene();		var camera = new THREE.PerspectiveCamera(35, w / h, 1, 1000);	scene.add(camera);		var renderer = new THREE.WebGLRenderer({antialias: false});	renderer.setSize(w, h);	renderer.setClearColorHex(0x000000, 0.0);	container.appendChild(renderer.domElement);		var itemsmeshes = [];		render();		var items = new Image();	items.onload = function () {				itemsc.clearRect(0, 0, itemscanvas.width, itemscanvas.height);		itemsc.drawImage(items, 0, 0);		//itemsMaterial.map.needsUpdate = true;				for(var i=0; i < 16*16; i++) {			var item = createItem(i);			item.position.x = Math.random()*200-100;			item.position.y = Math.random()*256-128;			item.position.z = Math.random()*200-100;			scene.add(item);			itemsmeshes.push(item);		}	};		items.src = "items.png";		}(window));
