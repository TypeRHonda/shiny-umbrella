#if defined(_MSC_VER)#ifndef _CRT_SECURE_NO_DEPRECATE#define _CRT_SECURE_NO_DEPRECATE (1)#endif#pragma warning(disable : 4996)  //getch()를 사용하면 발생하는 오류 c4996를 무시#endif#include <stdio.h>#include <stdlib.h>#include <string.h>#include <Windows.h>#include <process.h>#include <time.h>#include <conio.h>#include "Character_Player.h"#define BUF_SIZE 100#define NAME_SIZE 30unsigned WINAPI SendMsg(void* arg);//쓰레드 전송함수unsigned WINAPI RecvMsg(void* arg);//쓰레드 수신함수void ErrorHandling(char* msg);char name[NAME_SIZE] = "[DEFAULT]";char msg[BUF_SIZE];char choose;int damage;int critical;player *my;int client(player *p) { WSADATA wsaData; SOCKET sock; SOCKADDR_IN serverAddr; HANDLE sendThread, recvThread; my = (player*)malloc(sizeof(player)); my = p; my->full_hp = 100; my->now_hp = my->full_hp; char myIp[100] = "211.183.30.128"; char port[100] = "50000"; char inputName[100]; /* if(argc!=4){ printf("Usage : %s <IP> <port> <name>\n",argv[0]); exit(1); } */ strcpy(inputName, my->player_name); if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)// 윈도우 소켓을 사용한다고 운영체제에 알림  ErrorHandling("WSAStartup() error!"); sprintf(name, "%s", inputName); sock = socket(PF_INET, SOCK_STREAM, 0);//소켓을 하나 생성한다. memset(&serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_family = AF_INET; serverAddr.sin_addr.s_addr = inet_addr(myIp); serverAddr.sin_port = htons(atoi(port)); if (connect(sock, (SOCKADDR*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR)//서버에 접속한다.  ErrorHandling("connect() error"); //접속에 성공하면 이 줄 아래가 실행된다. sendThread = (HANDLE)_beginthreadex(NULL, 0, SendMsg, (void*)&sock, 0, NULL);//메시지 전송용 쓰레드가 실행된다. recvThread = (HANDLE)_beginthreadex(NULL, 0, RecvMsg, (void*)&sock, 0, NULL);//메시지 수신용 쓰레드가 실행된다. WaitForSingleObject(sendThread, INFINITE);//전송용 쓰레드가 중지될때까지 기다린다./ WaitForSingleObject(recvThread, INFINITE);//수신용 쓰레드가 중지될때까지 기다린다.             //클라이언트가 종료를 시도한다면 이줄 아래가 실행된다. closesocket(sock);//소켓을 종료한다. WSACleanup();//윈도우 소켓 사용중지를 운영체제에 알린다. return 0;}unsigned WINAPI SendMsg(void* arg) {//전송용 쓰레드함수 SOCKET sock = *((SOCKET*)arg);//서버용 소켓을 전달한다. char nameMsg[NAME_SIZE + BUF_SIZE]; while (1) {//반복  if (my->now_hp<=0) {//q를 입력하면 종료한다.   printf("your lose\n");   send(sock, "lose", 1, 0);//nameMsg를 서버에게 전송한다.  }  printf("1. 공격 2. 항복\n");  choose = getch();  switch (choose) {   case 1:    srand((unsigned int)time(NULL));    if (rand() % 20 == 0) { //miss확률     sprintf(nameMsg, "%s %d", name, 0); //nameMsg에 메시지를 전달한다.     send(sock, nameMsg, strlen(nameMsg), 0); //nameMsg를 서버에게 전송한다.     continue;    }    else if (rand() % 20 == 0) { //critical 확률     sprintf(nameMsg, "%s %d", name, 20);     send(sock, nameMsg, strlen(nameMsg), 0);     continue;    }    else { //보통 공격     sprintf(nameMsg, "%s %d", name, rand()%8+5);     send(sock, nameMsg, strlen(nameMsg), 0);     continue;    }    break;   case 2:    send(sock, "lose", 1, 0);    break;  } } return 0;}unsigned WINAPI RecvMsg(void* arg) { SOCKET sock = *((SOCKET*)arg);//서버용 소켓을 전달한다. char nameMsg[NAME_SIZE + BUF_SIZE]; int strLen; char *result; //문자열 분리 char name[8]; int damage; while (1) {//반복  strLen = recv(sock, nameMsg, NAME_SIZE + BUF_SIZE - 1, 0);//서버로부터 메시지를 수신한다.  if (strLen == -1)   return -1;  nameMsg[strLen] = 0;//문자열의 끝을 알리기 위해 설정  if (!strcmp(nameMsg, "lose")) {   printf("your win\n");   closesocket(sock);   return 0;  }  result = strtok(nameMsg, " ");  strcmp(name, result);  result = strtok(NULL, " ");  damage = atoi(result);  my->now_hp = my->now_hp - damage;  printf("%s의 공격 [%s]는 %d의 데미지\n", name, my->player_name, damage); } return 0;}void ErrorHandling(char* msg) { fputs(msg, stderr); fputc('\n', stderr); exit(1);}
